package ember.server.net;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.channels.SocketChannel;
import java.util.HashMap;
import java.util.Map;

import ember.engine.net.SocketStream;
import ember.server.Constants;
import ember.server.Server;
import ember.util.Logger;

public class SocketManager {
	/**
	 * The socket channel used to accept connections.
	 */
	//private static ServerSocketChannel serverChannel;
	private static ServerSocket serverChannel;
	/**
	 * The map used to store incoming connection channels.
	 */
	private static Map <Integer,SocketChannel> connections = new HashMap<Integer, SocketChannel>();
	
	
	public static void listen(){		
		try {
		/*	serverChannel = ServerSocketChannel.open();
			serverChannel.configureBlocking(false);
			serverChannel.socket().bind(new InetSocketAddress(Server.PORT),Constants.BACKLOG);
		*/
			serverChannel = new ServerSocket(Server.PORT,Constants.BACKLOG);
		} catch (IOException e) {
			
			e.printStackTrace();
			System.err.println("Fatal: Cannot bind to socket.");
			System.exit(1);
		}
				
	}
	
	public static void acceptConnections(){
		try {
		//SocketChannel socketChannel;
		
			for (int i = 0; i<Constants.BACKLOG;i++){
				
					//socketChannel = serverChannel.accept();	if (socketChannel==null){break;}
					Socket s = serverChannel.accept();
					//Socket s = socketChannel.socket();
					String host = s.getInetAddress().getHostAddress();
					
					int id = getFreeConnectionId();
					if(id==-1){
						s.close();
						//socketChannel.close();
						Logger.getInstance().info("Connection refused: "+host+" - increase Constants.MAX_CONENCTIONS");
						break;
					}
					//Handle no more connections more gracefully - inform client?.
					

		                
					//connections.put(id,socketChannel);//Now do shit with it

					//TODO lower to prevent blocking?
					 s.setSoTimeout(60000);
		             s.setTcpNoDelay(true);
		             
					GameConnection gc = new GameConnection(s,"");
					//SocketStream ss = new SocketStream(s);
					//gc.setSocketStream(ss);
					
					//TODO antiflood

					gc.out.write(123);
					gc.out.write(123);
					
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					System.out.println("IN FROM CLIENT: "+gc.in.read());
					Logger.getInstance().info("Connection accepted: "+host);

				} 
				
				
			}
		
		catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private static void checkConnections() {

		for (int i=0;i<Constants.MAX_CONNECTIONS;i++){
			if (connections.get(i)==null){break;}
					
			
			if (!connections.get(i).isConnected()){
				Logger.getInstance().warning("Not connected?");
			}if (!connections.get(i).isOpen()){
				Logger.getInstance().warning("Not open?");
			}
			/*if (!connections.get(i).isRegistered()){
				Logger.getInstance().warning("Not registered?");
			}*/
			if (!connections.get(i).socket().isBound()){
				Logger.getInstance().warning("Not socket bound?");
			}
			if (connections.get(i).socket().isClosed()){
				Logger.getInstance().warning("Socket closed?");
			}
			if (!connections.get(i).socket().isConnected()){
				Logger.getInstance().warning("Not socket connected?");
			}/*
			if (!connections.get(i).isRegistered()){
				Logger.getInstance().warning("Not socket registered?");
			}*/
			if (connections.get(i).socket().isInputShutdown()){
				Logger.getInstance().warning("Input Shutdown");
			}
			if (connections.get(i).socket().isOutputShutdown()){
				Logger.getInstance().warning("Output Shutdown");
			}
			//TODO Check here - then remove dead ones.	
			
		}
	}
	
	public static void dropConnection (Connection c){
		removeConnection(c.connectionId);
	}
	public static void removeConnection (int ID){
		SocketChannel sc = connections.get(ID);
		try {
			sc.socket().close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		connections.remove(ID);
	}
	
	public static void processEvents() {
		acceptConnections();
		checkConnections();
	}

	public static void dropConnection(int i){
		try {
			Logger.getInstance().info("Connection dropped: "+connections.get(i).socket().getInetAddress().getHostAddress());
			
			connections.get(i).socket().shutdownOutput();
			connections.get(i).socket().shutdownInput();
			connections.get(i).socket().close();
			connections.get(i).close();
			connections.put(i, null);
			
			//TODO kill GameConnection too
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

    public Map<Integer, SocketChannel> getConnections() {
        return connections;
    }
    
	private static int getFreeConnectionId(){
		
		for (int i=0; i<Constants.MAX_CONNECTIONS;i++){
			if (connections.get(i)==null)
			{return i;}
		}
		Logger.getInstance().warning("No more free socket channels - connection must be refused!");
		return -1;
	}

	public static SocketChannel getSocketChannel(int connectionId) {
		return connections.get(connectionId);
	}
	public static Socket getSocket(int connectionId) {
		// TODO Check
		return connections.get(connectionId).socket();
	}
}
